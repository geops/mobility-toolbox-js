/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/calls/{train_id}/': {
    /**
     * Get the stop sequences for the current journeys of the given train
     *
     * This is equivalent to calling
     *
     *     GET stopsequence_<train_id>
     *
     * on the websocket.
     */
    get: operations['calls_calls__train_id___get'];
  };
  '/feeds/': {
    /**
     * Get a list of all active feeds
     *
     * This is the only endpoint without Websocket API equivalent, where this info
     * is not needed normally (the `BBOX` command picks all the relevant data for
     * you).
     */
    get: operations['feeds_feeds__get'];
  };
  '/journeys/{train_id}/': {
    /**
     * Get geometries for the current journeys of the given train
     *
     * The `FeatureCollection` includes `Feature`s with `GeometryCollections` for
     * each journey where the `MultiPoint` geometry represents the stop points and
     * the `LineString` the full trajectory.
     *
     * This is equivalent to calling
     *
     *     GET full_trajectory_<train_id>
     *
     * on the websocket with gen_level and graph as in the BBOX command.
     */
    get: operations['full_trajectory_journeys__train_id___get'];
  };
  '/lines/{tag}/': {
    /**
     * Get all lines with the given tag
     *
     * Optionally filter by operator_name and name.
     *
     * Optionally return the data as GeoJSON. This requires `name` and
     * `operator_name` to be set. By default only ungenealized data is
     * returned. Set `graph` to select another line network.
     */
    get: operations['get_lines_for_tag_lines__tag___get'];
  };
  '/lines/{tag}/vias/': {
    /**
     * Return matching lines with a list of stop lists for routing
     *
     * Each item in the vias list should be treated as a list of vias for the Routing-API.
     * The goal of this method is to compile an undirected, routable representation of the
     * line, values are meaningless apart from that.
     */
    get: operations['get_via_stops_lines__tag__vias__get'];
  };
  '/trains_by_route_identifier/{feed_name}/': {
    /** Search for active trains in a specific feed/tenant by route identifier. */
    get: operations['trains_by_route_identifier_trains_by_route_identifier__feed_name___get'];
  };
  '/trajectories/{feed_name}/': {
    /**
     * Get all current trajectories between two stops for the given feed
     *
     * This is roughly equivalent to calling
     *
     *     BBOX <x_min> <y_min> <x_max> <y_max> <zoom> [tenant=<feed_name>] [gen_level=<gen_level>] [graph=graph]
     *
     * on the websocket but does not support all Websocket API parameters and
     * `feed_name` is not optional for the HTTP-API. Geometries are not simplified as
     * in the BBOX command.
     */
    get: operations['trajectories_trajectories__feed_name___get'];
  };
}

export interface components {
  schemas: {
    /** Feed */
    Feed: {
      /** Bbox */
      bbox?: Partial<number[]> & Partial<unknown>;
      /** Color */
      color: string;
      /** Has Realtime Feed */
      has_realtime_feed: boolean;
      license: components['schemas']['License'];
      /** Name */
      name: Partial<string> & Partial<unknown>;
      /** Short Name */
      short_name: string;
      /** Trajectory Count */
      trajectory_count?: Partial<number> & Partial<unknown>;
      /** Url */
      url: Partial<string> & Partial<unknown>;
      /** Valid From */
      valid_from: Partial<number> & Partial<unknown>;
      /** Valid To */
      valid_to: Partial<number> & Partial<unknown>;
      /** Version */
      version: Partial<string> & Partial<unknown>;
      /** X */
      x?: Partial<number> & Partial<unknown>;
      /** Y */
      y?: Partial<number> & Partial<unknown>;
    };
    /** FeedCollection */
    FeedCollection: {
      /** Feed Count */
      feed_count: number;
      /** Feeds */
      feeds: Record<string, unknown>;
      /** Trajectory Count */
      trajectory_count?: Partial<number> & Partial<unknown>;
    };
    /**
     * FullTrajectory
     * @description The trajectory for one of the journeys of a train as a GeoJSON Feature.
     *
     * The `geometry` is either a (Multi)LineString or a GeometryCollection of a
     * (Multi)LineString and a MultiPoint. If the MultiPoint is delivered, the points
     * correspond to stops projected onto the trajectory.
     *
     * MultiLineStrings can occur when the trajectory is discontinous at at least one of
     * the stops.
     */
    FullTrajectory: {
      /** Geometry */
      geometry: Partial<components['schemas']['GeometryCollectionGeometry']> &
        Partial<components['schemas']['LineStringGeometry']> &
        Partial<components['schemas']['MultiLineStringGeometry']>;
      properties: components['schemas']['FullTrajectoryProperties'];
      /**
       * Type
       * @constant
       */
      type: 'Feature';
    };
    /**
     * FullTrajectoryCollection
     * @description All trajectories for the journeys of a train as a GeoJSON FeatureCollection.
     */
    FullTrajectoryCollection: {
      /** Features */
      features: components['schemas']['FullTrajectory'][];
      properties: components['schemas']['FullTrajectoryCollectionProperties'];
      /**
       * Type
       * @constant
       */
      type: 'FeatureCollection';
    };
    /** FullTrajectoryCollectionProperties */
    FullTrajectoryCollectionProperties: {
      /** Gen Level */
      gen_level: Partial<number> & Partial<unknown>;
      /** Gen Range */
      gen_range: number[];
      /** Graph */
      graph: string;
      /** License */
      license?: Partial<string> & Partial<unknown>;
      /** Licensenote */
      licenseNote?: Partial<string> & Partial<unknown>;
      /** Licenseurl */
      licenseUrl?: Partial<string> & Partial<unknown>;
      /** Operator */
      operator?: Partial<string> & Partial<unknown>;
      /** Operatorurl */
      operatorUrl?: Partial<string> & Partial<unknown>;
      /** Publisher */
      publisher?: Partial<string> & Partial<unknown>;
      /** Publisherurl */
      publisherUrl?: Partial<string> & Partial<unknown>;
      /** Tenant */
      tenant?: string;
      /** Train Id */
      train_id: string;
    };
    /** FullTrajectoryProperties */
    FullTrajectoryProperties: {
      /** Event Timestamp */
      event_timestamp?: Partial<number> & Partial<unknown>;
      /** Gen Level */
      gen_level: Partial<number> & Partial<unknown>;
      /** Gen Range */
      gen_range: number[];
      /** Graph */
      graph: string;
      /** Journey Id */
      journey_id: number;
      /** Line Id */
      line_id: number;
      /** Line Name */
      line_name?: Partial<string> & Partial<unknown>;
      /** Stroke */
      stroke?: Partial<string> & Partial<unknown>;
      /** Train Id */
      train_id: string;
      /** Type */
      type?: Partial<
        | 'bus'
        | 'cablecar'
        | 'coach'
        | 'ferry'
        | 'funicular'
        | 'gondola'
        | 'rail'
        | 'subway'
        | 'tram'
      > &
        Partial<unknown>;
    };
    /**
     * GeometryCollectionGeometry
     * @description Collection of MultiPoint, LineString and MultiLineString
     *
     * MultiPoint is a list of points of interest, i.e. stop points in this
     * context. (Multi)LineStrings represent a trajectory.
     */
    GeometryCollectionGeometry: {
      /** Geometries */
      geometries: (Partial<components['schemas']['LineStringGeometry']> &
        Partial<components['schemas']['MultiLineStringGeometry']> &
        Partial<components['schemas']['MultiPointGeometry']>)[];
      /**
       * Type
       * @constant
       */
      type: 'GeometryCollection';
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components['schemas']['ValidationError'][];
    };
    /** JourneyExtraData */
    JourneyExtraData: {
      /** Event Location Name */
      event_location_name?: Partial<string> & Partial<unknown>;
      /** Event Timestamp */
      event_timestamp?: Partial<string> & Partial<unknown>;
    };
    /** License */
    License: {
      /** Name */
      name: Partial<string> & Partial<unknown>;
      /** Note */
      note: Partial<string> & Partial<unknown>;
      /** Url */
      url: Partial<string> & Partial<unknown>;
    };
    /** Line */
    Line: {
      /** Color */
      color: Partial<string> & Partial<unknown>;
      /** Id */
      id: number;
      /** Name */
      name: Partial<string> & Partial<unknown>;
      /** Stroke */
      stroke: Partial<string> & Partial<unknown>;
      /** Tags */
      tags: string[];
      /** Text Color */
      text_color: Partial<string> & Partial<unknown>;
    };
    /** LineStringGeometry */
    LineStringGeometry: {
      /** Coordinates */
      coordinates: Partial<number>[][];
      /**
       * Type
       * @constant
       */
      type: 'LineString';
    };
    /** LineViaStop */
    LineViaStop: {
      /** Lat */
      lat: number;
      /** Lon */
      lon: number;
      /** Name */
      name: string;
    };
    /** MultiLineStringGeometry */
    MultiLineStringGeometry: {
      /** Coordinates */
      coordinates: Partial<number>[][][];
      /**
       * Type
       * @constant
       */
      type: 'MultiLineString';
    };
    /** MultiPointGeometry */
    MultiPointGeometry: {
      /** Coordinates */
      coordinates: Partial<number>[][];
      /**
       * Type
       * @constant
       */
      type: 'MultiPoint';
    };
    /** RouteIdentifierMatch */
    RouteIdentifierMatch: {
      /** Bounds */
      bounds: number[];
      /** Destination */
      destination: Partial<string> & Partial<unknown>;
      /** Exact Match */
      exact_match: boolean;
      line: components['schemas']['Line'];
      /** Route Identifier */
      route_identifier: string;
      /** Train Id */
      train_id: string;
    };
    /** SerializedCancellationChange */
    SerializedCancellationChange: {
      /** New To */
      new_to?: Partial<string> & Partial<unknown>;
      /** No Stop Between */
      no_stop_between?: (Partial<string> & Partial<unknown>)[];
      /** No Stop Till */
      no_stop_till?: Partial<string> & Partial<unknown>;
      /** Old To */
      old_to?: Partial<string> & Partial<unknown>;
      /** State */
      state?: Partial<
        | 'BOARDING'
        | 'JOURNEY_CANCELLED'
        | 'LEAVING'
        | 'PENDING'
        | 'STOP_CANCELLED'
        | 'TIME_BASED'
      > &
        Partial<unknown>;
    };
    /** Situation */
    Situation: {
      /** Description */
      description: Partial<string> & Partial<unknown>;
    };
    /** StopSequence */
    StopSequence: {
      /** Color */
      color?: Partial<string> & Partial<unknown>;
      /** Destination */
      destination: Partial<string> & Partial<unknown>;
      extra_data: components['schemas']['JourneyExtraData'];
      /** Has Realtime */
      has_realtime: boolean;
      /** Has Realtime Journey */
      has_realtime_journey: boolean;
      /** Id */
      id: string;
      /** License */
      license?: Partial<string> & Partial<unknown>;
      /** Licensenote */
      licenseNote?: Partial<string> & Partial<unknown>;
      /** Licenseurl */
      licenseUrl?: Partial<string> & Partial<unknown>;
      line: Partial<components['schemas']['Line']> & Partial<unknown>;
      /** Longname */
      longName?: Partial<string> & Partial<unknown>;
      /** New Destination */
      new_destination: Partial<string> & Partial<unknown>;
      /** Operator */
      operator?: Partial<string> & Partial<unknown>;
      /**
       * Operator Provides Realtime Journey
       * @enum {string}
       */
      operator_provides_realtime_journey: 'maybe' | 'no' | 'unknown' | 'yes';
      /** Operatorurl */
      operatorUrl?: Partial<string> & Partial<unknown>;
      /** Publisher */
      publisher?: Partial<string> & Partial<unknown>;
      /** Publisherurl */
      publisherUrl?: Partial<string> & Partial<unknown>;
      /** Routeidentifier */
      routeIdentifier: Partial<string> & Partial<unknown>;
      /** Shortname */
      shortName?: Partial<string> & Partial<unknown>;
      /** Situations */
      situations: components['schemas']['Situation'][];
      /** Stations */
      stations: components['schemas']['StopSequenceCall'][];
      /** Stroke */
      stroke?: Partial<string> & Partial<unknown>;
      /** Tenant */
      tenant?: string;
      /** Text Color */
      text_color?: Partial<string> & Partial<unknown>;
      /** Train Number */
      train_number: Partial<number> & Partial<unknown>;
      /** Type */
      type: Partial<
        | 'bus'
        | 'cablecar'
        | 'coach'
        | 'ferry'
        | 'funicular'
        | 'gondola'
        | 'rail'
        | 'subway'
        | 'tram'
      > &
        Partial<unknown>;
      /** Vehicle Mode */
      vehicle_mode: Partial<string> & Partial<unknown>;
    };
    /** StopSequenceCall */
    StopSequenceCall: {
      /** Aimedarrivaltime */
      aimedArrivalTime: Partial<number> & Partial<unknown>;
      /** Aimeddeparturetime */
      aimedDepartureTime: Partial<number> & Partial<unknown>;
      /** Arrivaldelay */
      arrivalDelay: Partial<number> & Partial<unknown>;
      /** Arrivaltime */
      arrivalTime: Partial<number> & Partial<unknown>;
      /** Cancelled */
      cancelled: boolean;
      /** Changes */
      changes?: components['schemas']['SerializedCancellationChange'][];
      /** Coordinate */
      coordinate: Partial<number>[];
      /** Departuredelay */
      departureDelay: Partial<number> & Partial<unknown>;
      /** Departuretime */
      departureTime: Partial<number> & Partial<unknown>;
      /** Formation Id */
      formation_id: Partial<number> & Partial<unknown>;
      /** Nodropoff */
      noDropOff: Partial<boolean> & Partial<unknown>;
      /** Nopickup */
      noPickUp: Partial<boolean> & Partial<unknown>;
      /** Platform */
      platform: Partial<string> & Partial<unknown>;
      /** State */
      state?: Partial<
        | 'BOARDING'
        | 'JOURNEY_CANCELLED'
        | 'LEAVING'
        | 'PENDING'
        | 'STOP_CANCELLED'
        | 'TIME_BASED'
      > &
        Partial<unknown>;
      /** Stationid */
      stationId: Partial<number> & Partial<unknown>;
      /** Stationname */
      stationName: Partial<string> & Partial<unknown>;
      /** Stopuid */
      stopUID: Partial<string> & Partial<unknown>;
    };
    /** TagLineDetail */
    TagLineDetail: {
      /** Color */
      color: Partial<string> & Partial<unknown>;
      /** Id */
      id: number;
      /** Mot */
      mot: Partial<'unknown'> &
        Partial<
          | 'bus'
          | 'cablecar'
          | 'coach'
          | 'ferry'
          | 'funicular'
          | 'gondola'
          | 'rail'
          | 'subway'
          | 'tram'
        >;
      /** Name */
      name: Partial<string> & Partial<unknown>;
      /** Operator Name */
      operator_name: Partial<string> & Partial<unknown>;
      /** Short Name */
      short_name: Partial<string> & Partial<unknown>;
      /** Stroke */
      stroke: Partial<string> & Partial<unknown>;
      /** Tags */
      tags: string[];
      /** Text Color */
      text_color: Partial<string> & Partial<unknown>;
    };
    /** TagLineDetailWithVias */
    TagLineDetailWithVias: {
      /** Color */
      color: Partial<string> & Partial<unknown>;
      /** Id */
      id: number;
      /** Mot */
      mot: Partial<'unknown'> &
        Partial<
          | 'bus'
          | 'cablecar'
          | 'coach'
          | 'ferry'
          | 'funicular'
          | 'gondola'
          | 'rail'
          | 'subway'
          | 'tram'
        >;
      /** Name */
      name: Partial<string> & Partial<unknown>;
      /** Operator Name */
      operator_name: Partial<string> & Partial<unknown>;
      /** Short Name */
      short_name: Partial<string> & Partial<unknown>;
      /** Stroke */
      stroke: Partial<string> & Partial<unknown>;
      /** Tags */
      tags: string[];
      /** Text Color */
      text_color: Partial<string> & Partial<unknown>;
      /** Vias */
      vias: components['schemas']['LineViaStop'][][];
    };
    /**
     * TrackerTrajectory
     * @description Current section of the route the given train is on as a GeoJSON Feature.
     *
     * The `geometry` contains the LineString between two stops.
     *
     * The `time_intervals` property contains a list of `[timestamp, fraction,
     * direction]` tuples.
     *
     * Each `time_intervals` item contains the fraction of the geometry where
     * the vehicle is at the given timestamp. If present the direction is the
     * current rotation of the vehicle relative to the horizontal axis as
     * radian.
     *
     * The current location of the vehicle can be calculated by
     * linear interpolation from the fraction of the first item where the
     * timestamp is smaller then the current time to the fraction of the next
     * item.
     *
     * If the last timestamp is in the past, the trajectory should not be visualized by a
     * client.
     */
    TrackerTrajectory: {
      geometry: components['schemas']['LineStringGeometry'];
      properties: components['schemas']['TrackerTrajectoryProperties'];
      /**
       * Type
       * @constant
       */
      type: 'Feature';
    };
    /** TrackerTrajectoryProperties */
    TrackerTrajectoryProperties: {
      /** Bounds */
      bounds: number[];
      /** Delay */
      delay?: Partial<number> & Partial<unknown>;
      /** Event Timestamp */
      event_timestamp?: Partial<number> & Partial<unknown>;
      /** Gen Level */
      gen_level: Partial<number> & Partial<unknown>;
      /** Gen Range */
      gen_range: number[];
      /** Graph */
      graph: string;
      /** Has Journey */
      has_journey: boolean;
      /** Has Realtime */
      has_realtime: boolean;
      /** Has Realtime Journey */
      has_realtime_journey: boolean;
      line?: Partial<components['schemas']['Line']> & Partial<unknown>;
      /**
       * Operator Provides Realtime Journey
       * @enum {string}
       */
      operator_provides_realtime_journey: 'maybe' | 'no' | 'unknown' | 'yes';
      /** Route Identifier */
      route_identifier?: Partial<string> & Partial<unknown>;
      /** State */
      state?: Partial<'BOARDING' | 'DRIVING' | 'JOURNEY_CANCELLED'> &
        Partial<unknown>;
      /** Tenant */
      tenant: string;
      /** Time Intervals */
      time_intervals: (Partial<number> & Partial<unknown>)[][];
      /** Time Since Update */
      time_since_update?: Partial<number> & Partial<unknown>;
      /**
       * Timestamp
       * Format: date-time
       */
      timestamp: number;
      /** Train Id */
      train_id: string;
      /**
       * Type
       * @enum {string}
       */
      type:
        | 'bus'
        | 'cablecar'
        | 'coach'
        | 'ferry'
        | 'funicular'
        | 'gondola'
        | 'rail'
        | 'subway'
        | 'tram';
    };
    /** TrainsByRouteIdentifierResult */
    TrainsByRouteIdentifierResult: {
      /** Matches */
      matches: components['schemas']['RouteIdentifierMatch'][];
    };
    /** TrajectoryCollection */
    TrajectoryCollection: {
      /** Features */
      features: components['schemas']['TrackerTrajectory'][];
      /**
       * Type
       * @default FeatureCollection
       * @constant
       */
      type?: 'FeatureCollection';
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (Partial<number> & Partial<string>)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
  };
}

export interface operations {
  /**
   * Get the stop sequences for the current journeys of the given train
   *
   * This is equivalent to calling
   *
   *     GET stopsequence_<train_id>
   *
   * on the websocket.
   */
  calls_calls__train_id___get: {
    parameters: {
      path: {
        train_id: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          'application/json': components['schemas']['StopSequence'][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  /**
   * Get a list of all active feeds
   *
   * This is the only endpoint without Websocket API equivalent, where this info
   * is not needed normally (the `BBOX` command picks all the relevant data for
   * you).
   */
  feeds_feeds__get: {
    parameters: {
      query: {
        include_counts?: boolean;
        raw_data?: boolean;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          'application/json': components['schemas']['FeedCollection'];
        };
      };
      /** Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  /**
   * Get geometries for the current journeys of the given train
   *
   * The `FeatureCollection` includes `Feature`s with `GeometryCollections` for
   * each journey where the `MultiPoint` geometry represents the stop points and
   * the `LineString` the full trajectory.
   *
   * This is equivalent to calling
   *
   *     GET full_trajectory_<train_id>
   *
   * on the websocket with gen_level and graph as in the BBOX command.
   */
  full_trajectory_journeys__train_id___get: {
    parameters: {
      path: {
        train_id: string;
      };
      query: {
        channel_prefix?: string;
        gen_level?: Partial<number> & Partial<unknown>;
        graph?: Partial<string> & Partial<unknown>;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          'application/json': components['schemas']['FullTrajectoryCollection'];
        };
      };
      /** Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  /**
   * Get all lines with the given tag
   *
   * Optionally filter by operator_name and name.
   *
   * Optionally return the data as GeoJSON. This requires `name` and
   * `operator_name` to be set. By default only ungenealized data is
   * returned. Set `graph` to select another line network.
   */
  get_lines_for_tag_lines__tag___get: {
    parameters: {
      path: {
        tag: string;
      };
      query: {
        format?: 'geojson' | 'json';
        graph?: Partial<string> & Partial<unknown>;
        name?: Partial<string> & Partial<unknown>;
        operator_name?: Partial<string> & Partial<unknown>;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          'application/json': components['schemas']['TagLineDetail'][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  /**
   * Return matching lines with a list of stop lists for routing
   *
   * Each item in the vias list should be treated as a list of vias for the Routing-API.
   * The goal of this method is to compile an undirected, routable representation of the
   * line, values are meaningless apart from that.
   */
  get_via_stops_lines__tag__vias__get: {
    parameters: {
      path: {
        tag: string;
      };
      query: {
        name?: Partial<string> & Partial<unknown>;
        operator_name?: Partial<string> & Partial<unknown>;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          'application/json': components['schemas']['TagLineDetailWithVias'][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  /** Search for active trains in a specific feed/tenant by route identifier. */
  trains_by_route_identifier_trains_by_route_identifier__feed_name___get: {
    parameters: {
      path: {
        /** The feed name (aka tenant short name). */
        feed_name: string;
      };
      query: {
        /** Whether the search is case sensitive. */
        case_sensitive?: boolean;
        /** Whether to return only exact matches (up to case sensitivity if applicable). If false, substring matches are also considered. */
        exact_match: boolean;
        /** Query to match against route identifiers. */
        query?: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          'application/json': components['schemas']['TrainsByRouteIdentifierResult'];
        };
      };
      /** Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  /**
   * Get all current trajectories between two stops for the given feed
   *
   * This is roughly equivalent to calling
   *
   *     BBOX <x_min> <y_min> <x_max> <y_max> <zoom> [tenant=<feed_name>] [gen_level=<gen_level>] [graph=graph]
   *
   * on the websocket but does not support all Websocket API parameters and
   * `feed_name` is not optional for the HTTP-API. Geometries are not simplified as
   * in the BBOX command.
   */
  trajectories_trajectories__feed_name___get: {
    parameters: {
      path: {
        feed_name: string;
      };
      query: {
        bbox?: Partial<string> & Partial<unknown>;
        channel_prefix?: string;
        gen_level?: Partial<number> & Partial<unknown>;
        graph?: Partial<string> & Partial<unknown>;
        /** @deprecated */
        validate_output?: boolean;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          'application/json': components['schemas']['TrajectoryCollection'];
        };
      };
      /** Validation Error */
      422: {
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
}
