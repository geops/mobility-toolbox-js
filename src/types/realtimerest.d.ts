/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/trajectories/{feed_name}/": {
    /**
     * Get all current trajectories between two stops for the given feed
     *
     * This is roughly equivalent to calling
     *
     *     BBOX <x_min> <y_min> <x_max> <y_max> <zoom> [tenant=<feed_name>] [gen_level=<gen_level>] [graph=graph]
     *
     * on the websocket but does not support all Websocket API parameters and
     * `feed_name` is not optional for the HTTP-API. Geometries are not simplified as
     * in the BBOX command.
     */
    get: operations["trajectories_trajectories__feed_name___get"];
  };
  "/trains_by_route_identifier/{feed_name}/": {
    /** Search for active trains in a specific feed/tenant by route identifier. */
    get: operations["trains_by_route_identifier_trains_by_route_identifier__feed_name___get"];
  };
  "/journeys/{train_id}/": {
    /**
     * Get geometries for the current journeys of the given train
     *
     * The `FeatureCollection` includes `Feature`s with `GeometryCollections` for
     * each journey where the `MultiPoint` geometry represents the stop points and
     * the `LineString` the full trajectory.
     *
     * This is equivalent to calling
     *
     *     GET full_trajectory_<train_id>
     *
     * on the websocket with gen_level and graph as in the BBOX command.
     */
    get: operations["full_trajectory_journeys__train_id___get"];
  };
  "/calls/{train_id}/": {
    /**
     * Get the stop sequences for the current journeys of the given train
     *
     * This is equivalent to calling
     *
     *     GET stopsequence_<train_id>
     *
     * on the websocket.
     */
    get: operations["calls_calls__train_id___get"];
  };
  "/feeds/": {
    /**
     * Get a list of all active feeds
     *
     * This is the only endpoint without Websocket API equivalent, where this info
     * is not needed normally (the `BBOX` command picks all the relevant data for
     * you).
     */
    get: operations["feeds_feeds__get"];
  };
  "/lines/{tag}/vias/": {
    /**
     * Return matching lines with a list of stop lists for routing
     *
     * Each item in the vias list should be treated as a list of vias for the Routing-API.
     * The goal of this method is to compile an undirected, routable representation of the
     * line, values are meaningless apart from that.
     */
    get: operations["get_via_stops_lines__tag__vias__get"];
  };
  "/lines/{tag}/": {
    /**
     * Get all lines with the given tag
     *
     * Optionally filter by operator_name and name.
     *
     * Optionally return the data as GeoJSON. This requires `name` and
     * `operator_name` to be set. By default only ungenealized data is
     * returned. Set `graph` to select another line network.
     */
    get: operations["get_lines_for_tag_lines__tag___get"];
  };
}

export interface components {
  schemas: {
    /** Feed */
    Feed: {
      /** Short Name */
      short_name: string;
      /** Name */
      name: Partial<string> & Partial<unknown>;
      /** Url */
      url: Partial<string> & Partial<unknown>;
      /** Valid From */
      valid_from: Partial<number> & Partial<unknown>;
      /** Valid To */
      valid_to: Partial<number> & Partial<unknown>;
      /** Version */
      version: Partial<string> & Partial<unknown>;
      license: components["schemas"]["License"];
      /** Has Realtime Feed */
      has_realtime_feed: boolean;
      /** X */
      x?: Partial<number> & Partial<unknown>;
      /** Y */
      y?: Partial<number> & Partial<unknown>;
      /** Bbox */
      bbox?: Partial<number[]> & Partial<unknown>;
      /** Color */
      color: string;
      /** Trajectory Count */
      trajectory_count?: Partial<number> & Partial<unknown>;
    };
    /** FeedCollection */
    FeedCollection: {
      /** Trajectory Count */
      trajectory_count?: Partial<number> & Partial<unknown>;
      /** Feed Count */
      feed_count: number;
      /** Feeds */
      feeds: { [key: string]: unknown };
    };
    /**
     * FullTrajectory
     * @description The trajectory for one of the journeys of a train as a GeoJSON Feature.
     *
     * The `geometry` is either a (Multi)LineString or a GeometryCollection of a
     * (Multi)LineString and a MultiPoint. If the MultiPoint is delivered, the points
     * correspond to stops projected onto the trajectory.
     *
     * MultiLineStrings can occur when the trajectory is discontinous at at least one of
     * the stops.
     */
    FullTrajectory: {
      /**
       * Type
       * @constant
       */
      type: "Feature";
      /** Geometry */
      geometry: Partial<components["schemas"]["GeometryCollectionGeometry"]> &
        Partial<components["schemas"]["LineStringGeometry"]> &
        Partial<components["schemas"]["MultiLineStringGeometry"]>;
      properties: components["schemas"]["FullTrajectoryProperties"];
    };
    /**
     * FullTrajectoryCollection
     * @description All trajectories for the journeys of a train as a GeoJSON FeatureCollection.
     */
    FullTrajectoryCollection: {
      /**
       * Type
       * @constant
       */
      type: "FeatureCollection";
      properties: components["schemas"]["FullTrajectoryCollectionProperties"];
      /** Features */
      features: components["schemas"]["FullTrajectory"][];
    };
    /** FullTrajectoryCollectionProperties */
    FullTrajectoryCollectionProperties: {
      /** Tenant */
      tenant?: string;
      /** Publisher */
      publisher?: Partial<string> & Partial<unknown>;
      /** Publisherurl */
      publisherUrl?: Partial<string> & Partial<unknown>;
      /** Operator */
      operator?: Partial<string> & Partial<unknown>;
      /** Operatorurl */
      operatorUrl?: Partial<string> & Partial<unknown>;
      /** License */
      license?: Partial<string> & Partial<unknown>;
      /** Licenseurl */
      licenseUrl?: Partial<string> & Partial<unknown>;
      /** Licensenote */
      licenseNote?: Partial<string> & Partial<unknown>;
      /** Graph */
      graph: string;
      /** Gen Level */
      gen_level: Partial<number> & Partial<unknown>;
      /** Gen Range */
      gen_range: number[];
      /** Train Id */
      train_id: string;
    };
    /** FullTrajectoryProperties */
    FullTrajectoryProperties: {
      /** Stroke */
      stroke?: Partial<string> & Partial<unknown>;
      /** Line Name */
      line_name?: Partial<string> & Partial<unknown>;
      /** Type */
      type?: Partial<
        | "tram"
        | "subway"
        | "rail"
        | "bus"
        | "ferry"
        | "cablecar"
        | "gondola"
        | "funicular"
        | "coach"
      > &
        Partial<unknown>;
      /** Event Timestamp */
      event_timestamp?: Partial<number> & Partial<unknown>;
      /** Train Id */
      train_id: string;
      /** Journey Id */
      journey_id: number;
      /** Line Id */
      line_id: number;
      /** Graph */
      graph: string;
      /** Gen Level */
      gen_level: Partial<number> & Partial<unknown>;
      /** Gen Range */
      gen_range: number[];
    };
    /**
     * GeometryCollectionGeometry
     * @description Collection of MultiPoint, LineString and MultiLineString
     *
     * MultiPoint is a list of points of interest, i.e. stop points in this
     * context. (Multi)LineStrings represent a trajectory.
     */
    GeometryCollectionGeometry: {
      /**
       * Type
       * @constant
       */
      type: "GeometryCollection";
      /** Geometries */
      geometries: (Partial<components["schemas"]["LineStringGeometry"]> &
        Partial<components["schemas"]["MultiPointGeometry"]> &
        Partial<components["schemas"]["MultiLineStringGeometry"]>)[];
    };
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components["schemas"]["ValidationError"][];
    };
    /** JourneyExtraData */
    JourneyExtraData: {
      /** Event Timestamp */
      event_timestamp?: Partial<string> & Partial<unknown>;
      /** Event Location Name */
      event_location_name?: Partial<string> & Partial<unknown>;
    };
    /** License */
    License: {
      /** Name */
      name: Partial<string> & Partial<unknown>;
      /** Url */
      url: Partial<string> & Partial<unknown>;
      /** Note */
      note: Partial<string> & Partial<unknown>;
    };
    /** Line */
    Line: {
      /** Id */
      id: number;
      /** Name */
      name: Partial<string> & Partial<unknown>;
      /** Color */
      color: Partial<string> & Partial<unknown>;
      /** Text Color */
      text_color: Partial<string> & Partial<unknown>;
      /** Stroke */
      stroke: Partial<string> & Partial<unknown>;
      /** Tags */
      tags: string[];
    };
    /** LineStringGeometry */
    LineStringGeometry: {
      /**
       * Type
       * @constant
       */
      type: "LineString";
      /** Coordinates */
      coordinates: (Partial<number> & Partial<number>)[][];
    };
    /** LineViaStop */
    LineViaStop: {
      /** Name */
      name: string;
      /** Lat */
      lat: number;
      /** Lon */
      lon: number;
    };
    /** MultiLineStringGeometry */
    MultiLineStringGeometry: {
      /**
       * Type
       * @constant
       */
      type: "MultiLineString";
      /** Coordinates */
      coordinates: (Partial<number> & Partial<number>)[][][];
    };
    /** MultiPointGeometry */
    MultiPointGeometry: {
      /**
       * Type
       * @constant
       */
      type: "MultiPoint";
      /** Coordinates */
      coordinates: (Partial<number> & Partial<number>)[][];
    };
    /** RouteIdentifierMatch */
    RouteIdentifierMatch: {
      /** Train Id */
      train_id: string;
      line: components["schemas"]["Line"];
      /** Bounds */
      bounds: number[];
      /** Destination */
      destination: Partial<string> & Partial<unknown>;
      /** Route Identifier */
      route_identifier: string;
      /** Exact Match */
      exact_match: boolean;
    };
    /** SerializedCancellationChange */
    SerializedCancellationChange: {
      /** Old To */
      old_to?: Partial<string> & Partial<unknown>;
      /** State */
      state?: Partial<
        | "LEAVING"
        | "BOARDING"
        | "STOP_CANCELLED"
        | "JOURNEY_CANCELLED"
        | "TIME_BASED"
        | "PENDING"
      > &
        Partial<unknown>;
      /** New To */
      new_to?: Partial<string> & Partial<unknown>;
      /** No Stop Till */
      no_stop_till?: Partial<string> & Partial<unknown>;
      /** No Stop Between */
      no_stop_between?: (Partial<string> & Partial<unknown>)[];
    };
    /** Situation */
    Situation: {
      /** Description */
      description: Partial<string> & Partial<unknown>;
    };
    /** StopSequence */
    StopSequence: {
      /** Has Realtime */
      has_realtime: boolean;
      /** Has Realtime Journey */
      has_realtime_journey: boolean;
      /**
       * Operator Provides Realtime Journey
       * @enum {string}
       */
      operator_provides_realtime_journey: "yes" | "no" | "maybe" | "unknown";
      /** Tenant */
      tenant?: string;
      /** Publisher */
      publisher?: Partial<string> & Partial<unknown>;
      /** Publisherurl */
      publisherUrl?: Partial<string> & Partial<unknown>;
      /** Operator */
      operator?: Partial<string> & Partial<unknown>;
      /** Operatorurl */
      operatorUrl?: Partial<string> & Partial<unknown>;
      /** License */
      license?: Partial<string> & Partial<unknown>;
      /** Licenseurl */
      licenseUrl?: Partial<string> & Partial<unknown>;
      /** Licensenote */
      licenseNote?: Partial<string> & Partial<unknown>;
      /** Color */
      color?: Partial<string> & Partial<unknown>;
      /** Stroke */
      stroke?: Partial<string> & Partial<unknown>;
      /** Text Color */
      text_color?: Partial<string> & Partial<unknown>;
      /** Shortname */
      shortName?: Partial<string> & Partial<unknown>;
      /** Longname */
      longName?: Partial<string> & Partial<unknown>;
      /** Id */
      id: string;
      /** Vehicle Mode */
      vehicle_mode: Partial<string> & Partial<unknown>;
      /** Train Number */
      train_number: Partial<number> & Partial<unknown>;
      line: Partial<components["schemas"]["Line"]> & Partial<unknown>;
      /** Destination */
      destination: Partial<string> & Partial<unknown>;
      /** New Destination */
      new_destination: Partial<string> & Partial<unknown>;
      /** Routeidentifier */
      routeIdentifier: Partial<string> & Partial<unknown>;
      /** Situations */
      situations: components["schemas"]["Situation"][];
      /** Type */
      type: Partial<
        | "tram"
        | "subway"
        | "rail"
        | "bus"
        | "ferry"
        | "cablecar"
        | "gondola"
        | "funicular"
        | "coach"
      > &
        Partial<unknown>;
      extra_data: components["schemas"]["JourneyExtraData"];
      /** Stations */
      stations: components["schemas"]["StopSequenceCall"][];
    };
    /** StopSequenceCall */
    StopSequenceCall: {
      /** State */
      state?: Partial<
        | "LEAVING"
        | "BOARDING"
        | "STOP_CANCELLED"
        | "JOURNEY_CANCELLED"
        | "TIME_BASED"
        | "PENDING"
      > &
        Partial<unknown>;
      /** Changes */
      changes?: components["schemas"]["SerializedCancellationChange"][];
      /** Formation Id */
      formation_id: Partial<number> & Partial<unknown>;
      /** Arrivaldelay */
      arrivalDelay: Partial<number> & Partial<unknown>;
      /** Arrivaltime */
      arrivalTime: Partial<number> & Partial<unknown>;
      /** Aimedarrivaltime */
      aimedArrivalTime: Partial<number> & Partial<unknown>;
      /** Cancelled */
      cancelled: boolean;
      /** Departuredelay */
      departureDelay: Partial<number> & Partial<unknown>;
      /** Departuretime */
      departureTime: Partial<number> & Partial<unknown>;
      /** Aimeddeparturetime */
      aimedDepartureTime: Partial<number> & Partial<unknown>;
      /** Nodropoff */
      noDropOff: Partial<boolean> & Partial<unknown>;
      /** Nopickup */
      noPickUp: Partial<boolean> & Partial<unknown>;
      /** Stationid */
      stationId: Partial<number> & Partial<unknown>;
      /** Stationname */
      stationName: Partial<string> & Partial<unknown>;
      /** Coordinate */
      coordinate: (Partial<number> & Partial<number>)[];
      /** Platform */
      platform: Partial<string> & Partial<unknown>;
      /** Stopuid */
      stopUID: Partial<string> & Partial<unknown>;
    };
    /** TagLineDetail */
    TagLineDetail: {
      /** Id */
      id: number;
      /** Name */
      name: Partial<string> & Partial<unknown>;
      /** Color */
      color: Partial<string> & Partial<unknown>;
      /** Text Color */
      text_color: Partial<string> & Partial<unknown>;
      /** Stroke */
      stroke: Partial<string> & Partial<unknown>;
      /** Tags */
      tags: string[];
      /** Operator Name */
      operator_name: Partial<string> & Partial<unknown>;
      /** Short Name */
      short_name: Partial<string> & Partial<unknown>;
      /** Mot */
      mot: Partial<
        | "tram"
        | "subway"
        | "rail"
        | "bus"
        | "ferry"
        | "cablecar"
        | "gondola"
        | "funicular"
        | "coach"
      > &
        Partial<"unknown">;
    };
    /** TagLineDetailWithVias */
    TagLineDetailWithVias: {
      /** Id */
      id: number;
      /** Name */
      name: Partial<string> & Partial<unknown>;
      /** Color */
      color: Partial<string> & Partial<unknown>;
      /** Text Color */
      text_color: Partial<string> & Partial<unknown>;
      /** Stroke */
      stroke: Partial<string> & Partial<unknown>;
      /** Tags */
      tags: string[];
      /** Operator Name */
      operator_name: Partial<string> & Partial<unknown>;
      /** Short Name */
      short_name: Partial<string> & Partial<unknown>;
      /** Mot */
      mot: Partial<
        | "tram"
        | "subway"
        | "rail"
        | "bus"
        | "ferry"
        | "cablecar"
        | "gondola"
        | "funicular"
        | "coach"
      > &
        Partial<"unknown">;
      /** Vias */
      vias: components["schemas"]["LineViaStop"][][];
    };
    /**
     * TrackerTrajectory
     * @description Current section of the route the given train is on as a GeoJSON Feature.
     *
     * The `geometry` contains the LineString between two stops.
     *
     * The `time_intervals` property contains a list of `[timestamp, fraction,
     * direction]` tuples.
     *
     * Each `time_intervals` item contains the fraction of the geometry where
     * the vehicle is at the given timestamp. If present the direction is the
     * current rotation of the vehicle relative to the horizontal axis as
     * radian.
     *
     * The current location of the vehicle can be calculated by
     * linear interpolation from the fraction of the first item where the
     * timestamp is smaller then the current time to the fraction of the next
     * item.
     *
     * If the last timestamp is in the past, the trajectory should not be visualized by a
     * client.
     */
    TrackerTrajectory: {
      /**
       * Type
       * @constant
       */
      type: "Feature";
      geometry: components["schemas"]["LineStringGeometry"];
      properties: components["schemas"]["TrackerTrajectoryProperties"];
    };
    /** TrackerTrajectoryProperties */
    TrackerTrajectoryProperties: {
      /** Has Realtime */
      has_realtime: boolean;
      /** Has Realtime Journey */
      has_realtime_journey: boolean;
      /**
       * Operator Provides Realtime Journey
       * @enum {string}
       */
      operator_provides_realtime_journey: "yes" | "no" | "maybe" | "unknown";
      /** Graph */
      graph: string;
      /** Gen Level */
      gen_level: Partial<number> & Partial<unknown>;
      /** Gen Range */
      gen_range: number[];
      /**
       * Type
       * @enum {string}
       */
      type:
        | "tram"
        | "subway"
        | "rail"
        | "bus"
        | "ferry"
        | "cablecar"
        | "gondola"
        | "funicular"
        | "coach";
      /** Bounds */
      bounds: number[];
      /** Tenant */
      tenant: string;
      /** Time Intervals */
      time_intervals: (Partial<number> &
        Partial<number> &
        Partial<unknown>)[][];
      /** Train Id */
      train_id: string;
      /**
       * Timestamp
       * Format: date-time
       */
      timestamp: number;
      /** Has Journey */
      has_journey: boolean;
      /** Event Timestamp */
      event_timestamp?: Partial<number> & Partial<unknown>;
      line?: Partial<components["schemas"]["Line"]> & Partial<unknown>;
      /** State */
      state?: Partial<"DRIVING" | "BOARDING" | "JOURNEY_CANCELLED"> &
        Partial<unknown>;
      /** Time Since Update */
      time_since_update?: Partial<number> & Partial<unknown>;
      /** Delay */
      delay?: Partial<number> & Partial<unknown>;
      /** Route Identifier */
      route_identifier?: Partial<string> & Partial<unknown>;
    };
    /** TrainsByRouteIdentifierResult */
    TrainsByRouteIdentifierResult: {
      /** Matches */
      matches: components["schemas"]["RouteIdentifierMatch"][];
    };
    /** TrajectoryCollection */
    TrajectoryCollection: {
      /**
       * Type
       * @default FeatureCollection
       * @constant
       */
      type?: "FeatureCollection";
      /** Features */
      features: components["schemas"]["TrackerTrajectory"][];
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (Partial<string> & Partial<number>)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
  };
}

export interface operations {
  /**
   * Get all current trajectories between two stops for the given feed
   *
   * This is roughly equivalent to calling
   *
   *     BBOX <x_min> <y_min> <x_max> <y_max> <zoom> [tenant=<feed_name>] [gen_level=<gen_level>] [graph=graph]
   *
   * on the websocket but does not support all Websocket API parameters and
   * `feed_name` is not optional for the HTTP-API. Geometries are not simplified as
   * in the BBOX command.
   */
  trajectories_trajectories__feed_name___get: {
    parameters: {
      path: {
        feed_name: string;
      };
      query: {
        bbox?: Partial<string> & Partial<unknown>;
        gen_level?: Partial<number> & Partial<unknown>;
        channel_prefix?: string;
        /** @deprecated */
        validate_output?: boolean;
        graph?: Partial<string> & Partial<unknown>;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TrajectoryCollection"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /** Search for active trains in a specific feed/tenant by route identifier. */
  trains_by_route_identifier_trains_by_route_identifier__feed_name___get: {
    parameters: {
      path: {
        /** The feed name (aka tenant short name). */
        feed_name: string;
      };
      query: {
        /** Whether to return only exact matches (up to case sensitivity if applicable). If false, substring matches are also considered. */
        exact_match: boolean;
        /** Query to match against route identifiers. */
        query?: string;
        /** Whether the search is case sensitive. */
        case_sensitive?: boolean;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TrainsByRouteIdentifierResult"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get geometries for the current journeys of the given train
   *
   * The `FeatureCollection` includes `Feature`s with `GeometryCollections` for
   * each journey where the `MultiPoint` geometry represents the stop points and
   * the `LineString` the full trajectory.
   *
   * This is equivalent to calling
   *
   *     GET full_trajectory_<train_id>
   *
   * on the websocket with gen_level and graph as in the BBOX command.
   */
  full_trajectory_journeys__train_id___get: {
    parameters: {
      path: {
        train_id: string;
      };
      query: {
        gen_level?: Partial<number> & Partial<unknown>;
        channel_prefix?: string;
        graph?: Partial<string> & Partial<unknown>;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FullTrajectoryCollection"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get the stop sequences for the current journeys of the given train
   *
   * This is equivalent to calling
   *
   *     GET stopsequence_<train_id>
   *
   * on the websocket.
   */
  calls_calls__train_id___get: {
    parameters: {
      path: {
        train_id: string;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["StopSequence"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get a list of all active feeds
   *
   * This is the only endpoint without Websocket API equivalent, where this info
   * is not needed normally (the `BBOX` command picks all the relevant data for
   * you).
   */
  feeds_feeds__get: {
    parameters: {
      query: {
        include_counts?: boolean;
        raw_data?: boolean;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["FeedCollection"];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Return matching lines with a list of stop lists for routing
   *
   * Each item in the vias list should be treated as a list of vias for the Routing-API.
   * The goal of this method is to compile an undirected, routable representation of the
   * line, values are meaningless apart from that.
   */
  get_via_stops_lines__tag__vias__get: {
    parameters: {
      path: {
        tag: string;
      };
      query: {
        operator_name?: Partial<string> & Partial<unknown>;
        name?: Partial<string> & Partial<unknown>;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TagLineDetailWithVias"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
  /**
   * Get all lines with the given tag
   *
   * Optionally filter by operator_name and name.
   *
   * Optionally return the data as GeoJSON. This requires `name` and
   * `operator_name` to be set. By default only ungenealized data is
   * returned. Set `graph` to select another line network.
   */
  get_lines_for_tag_lines__tag___get: {
    parameters: {
      path: {
        tag: string;
      };
      query: {
        operator_name?: Partial<string> & Partial<unknown>;
        name?: Partial<string> & Partial<unknown>;
        format?: "json" | "geojson";
        graph?: Partial<string> & Partial<unknown>;
      };
    };
    responses: {
      /** Successful Response */
      200: {
        content: {
          "application/json": components["schemas"]["TagLineDetail"][];
        };
      };
      /** Validation Error */
      422: {
        content: {
          "application/json": components["schemas"]["HTTPValidationError"];
        };
      };
    };
  };
}

export interface external {}
